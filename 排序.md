## 时间复杂性
时间复杂性，就是时间复杂度，算法的时间复杂度是一个函数，大O符号表示，算法的复杂度是由**时间复杂度**和**空间复杂度**组成。
>时间复杂度
>是指执行算法所需要的计算工作量

>空间复杂度
>是指执行这个算法所需要的内存空间

## 选择排序
假如数组的长度是N，则时间复杂度：
+ 平均情况：O(n²)
+ 最好情况：O(n²)
+ 最坏情况：O(n²)

空间复杂度：O(1)

进行比较的次数： (N-1) + (N-2) ... + 1 = (N-1)N / 2
进行交换的次数为：N

[算法gif]: https://img2018.cnblogs.com/blog/1439869/201907/1439869-20190717181858504-1948293626.gif

## 插入排序
数组进行循环，后面和前面的比较，小的话，换位。
```javascript
const arr = [2,4,5,6,734,1,1,23, 13,45, 24,5567,2435,234,2341,341,234,123,12,3]
for (let i = 1; i < arr.length; i++) { // 设置为1是因为第一位不需要
  const A = arr[i]
  // 遍历i前面的
  for (let i2 = i; i2 > -1; i2--) {
    // 小到大进行排序
    if (A > arr[i2]) {
      arr.splice(i2, 0, A)
      break
    }
  }
}
```
时间复杂度：
+ 平均O(n²)
+ 最坏O(n²)
+ 最好O(n)

空间复杂度： O(1)

进行比较的次数：
+ 最坏：1 + 2 + 3 + 4 ... + N = N² / 2
+ 最好：1 + 1 + 1 ... + 1 = N - 1
+ 平均：没笔🖊... N*N / 4

[插入排序gif]: https://img2018.cnblogs.com/blog/1439869/201907/1439869-20190717181905771-748910235.gif

## 冒泡排序
代码实在不想写 两个for for 循环，不能打断，前后比较，按升降，进行小的往前
或者往后

时间复杂度：
+ 平均O(n²)
+ 最好O(n)
+ 最坏O(n²)

进行比较的次数：
+ 平均: (N-1) + (N-2) ... + 1 = (N-1)N / 2
+ 最好 是N-1 为什么？因为可以检测 第一次遍历的时候如果没有前后位置调换，那么可以断掉了。

[冒泡排序gif]: https://img2018.cnblogs.com/blog/1439869/201907/1439869-20190717181912469-1066135142.jpg


## 疏排序
```java
public static int[] combSort(int[] a) {
    int N = a.length;
    int step = N;
    int k;
    // 第一部分
    while((step /= 1.3) > 1) {
        for (int i = N-1; i >= step; i--) {
            k = i -step;
            if(a[k]>a[i]){
                // 交换位置
                exc(a, k, i);
            }
        }
    }
    // 第二部分：进行冒泡排序
    a= bubbleSort2(a);
    return a;
}
```
在梳排序中，原作者用随机数做实验，得到了最有效的递减效率是1.3。
也就是step/=1.3,同样也可以写成step *= 0.8,因为编程语言乘法比除法快。

## 希尔排序
希尔排序是基于插入排序进行改进的
