#### 都说要减少https请求，为什么要减少https请求？
>建立连接4次握手需要的时间，ssl需要的时间，证书需要的时间，如果是采用非对称性加密，就更加耗时间了。
代理服务器也有很多，转发，很消耗性能

#### 浏览器缓存的方法有哪些，它们的优先级是怎样的 ？
>浏览器本地缓存，代理缓存，浏览器检查Exprice的时间，max-age,如果没有在范围时间，则解释请求连接，
发送，if-not-modified请求头给服务器，和if-none-tag, 服务器判断，满足两个条件，则刷新Exprice
和max-age，返回304,代理服务器，进行缓存，返回给浏览器

正确答案
>1.service worker是运行在浏览器背后的独立线程，一般可以用来实现缓存功能，使用service worker的
话，传输协议必须为https,因为service worker中涉及到请求拦截，所以必须使用https协议来保障安全。
（出于安全考量，Service workers只能由HTTPS承载，毕竟修改网络请求的能力暴露给中间人攻击会非常危险
。但是在本地还是能跑起来的）
service worker的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件，如何
匹配缓存，如何读取缓存，并且缓存是持续性的。

>2.memory Cache 也就是内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式的脚本、
>图片等，读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭
>Tab页面，内存中的缓存也就被释放了。
>###### 既然内存这么高效，我们是不是能让数据都放在内存中呢？
>需要指的注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存偷Cache-Control是什么，同时资源的匹配也并
>非仅仅是怼URL做匹配，还可能会对Content-Type，CORS等其他特征做校验

>3.Disk Cache 也就是储存在硬盘中的缓存，读取速度慢点，但是什么都能存储到硬盘中，比之memory cache胜在容量和存储时效性上。
>根据http header中字段判断哪些需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同
>地址的资源一旦被硬盘缓存下来，就不会再次去请求数据，绝大部分的缓存都来自disk cache 关于http 的协议偷的缓存字段。

>4.Push cache 推送缓存，是http/2中的内容，当以上三种缓存都没有命中时，它才会被利用，它只在session会话中存在，一旦会话结束就被释放，
>并且缓存时间也很短暂，在chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令
>+ 所有的资源都能被推送，并且能够被缓存，edge 和 safari支持相对较差
>+ 可以推送no-cache和no-store的资源cache-Control:
>+ 一旦连接被关闭，push cache就被释放
>+ 多个页面可以使用同一个http/2的连接，也就是可以使用同一个push cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域但不同tag，使用同一个http连接
>+ push cache中的缓存只能被使用一次
>+ 浏览器可以拒绝接受已经存在的资源推送
>+ 你可以给其他域名推送资源

如果以上的四种缓存都没有命中的话，那么只能发起请求来获取资源了

缓存过程分析
>浏览器与服务器通讯的方式为应答模式，即是：浏览器发起http请求，服务器响应请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起请求后拿到请求结果后，将请求结果和缓存etag表示加入
>浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。

强缓存
>不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台network选项中可以看到该请求返回200的状态码，并且size显示from disk cache 或者 from memroy cache。强缓存可以通过设置两种
>http header实现，expires 和 cache-chontrol

缓存机制的思考，disk cache是保存在磁盘中的，不会访问服务器，memory cache是保存在缓存，内存中，
304 Not Modified 访问服务器，发现数据没有更新，服务器返回此状态码，然后从缓存中读取数据。
#### 三级缓存原理
+ 先去内存看，如果有，直接加载
+ 如果内存没有，择取硬盘获取，如果有直接加载
+ 如果硬盘也没有，那么就激励下那个网络请求
+ 加载到的资源缓存到硬盘内存

https://segmentfault.com/a/1190000011286027

https://www.jianshu.com/p/54cc04190252

#### http2 和 http1的区别
1.0 和 1.1的区别
>+ HTTP1.1 引入了range，断点续传,它允许只请求资源的某个部分，返回码是206(Partial Content)，这样就方便
>开发者自由的选择以便于充分利用带宽和连接。
>+ 错误通知管理，在HTTP1.1新增了23个错误状态响应码，409表示请求的资源与资源的当前状态发生冲突，410表示
>服务器上的某个资源被永久性的删除
>+ Host头处理，在HTTP1.0中认为每台服务器绑定一个唯一的ip地址，因此，请求消息中的URL并没有传递
>主机名称。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且他们共享一个IP地址，HTTP1.1的
>请求消息和响应消息都应该支持HOST头域，且请求消息中如果没有HOST头域会报告一个错误（400BAD REQUEST）
>+ 缓存处理 etag if-notmodified-since if-match if-none-match
>+ 长连接，HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应
>减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection:keep-alive，一定程度上弥补了HTTP1.0
>每次请求都需要创建连接的缺点

HTTPS和HTTP的一些区别
>+ HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
>+ HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之
>上，所有传输的内容都经过加密
>+ HTTP和HTTPS使用的是完全不痛的连接方式，用的端口也不一样，前者是80，后者是443
>+ HTTPS可以有效的防止运营商劫持，接却了防劫持的一个大问题

SPDY
>2012年google提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性
>+ 1.降低延迟：针对HTTP高延迟的问题，SPDY优雅的采取了多路复用，多路复用通过多个请求stream共享一个tcp连接方式，解决额HOL blocking的问题，降低了延迟同时提高了带宽的利用率
>+ 2.请求优先级。多路复用带来的一个新问题是，再连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个REQUEST设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的HTML内容应该优先
>展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容
